std := import('std')
str := import('str')
fmt := import('fmt')
http := import('http')

{ lru: lru } := import('lru')

endpoints := {
	_domain!: fn domain!(v) 'https://libraryofbabel.info/' << v
	_cgi!: fn cgi!(xu) domain!(xu) << '.cgi'

	book: 'book' |> cgi!()
	search: 'search' |> cgi!()
	titler: 'titler' |> cgi!()
	browse: 'browse' |> cgi!()
	download: 'download' |> cgi!()
	anglishize: 'anglishize' |> cgi!()
	bookmarker: 'bookmarker' |> cgi!()
	resourcelocator: 'resourcelocator' |> cgi!()
}

// ---

fn query(seed, wall, ch, vol, page) {
	rest := '{{0}}-w{{1}}-s{{2}}-v{{3}}'
	if page != ? -> rest << ':' << string(page)

	rest |> fmt.format(
		seed |> string()
		wall |> string()
		ch |> string()
		vol |> string() |> str.padStart(2, '0')
	)
}

fn bookmarkQuery(name, index) {
	'{{0}}:{{1}}' |> fmt.format(
		name
		index |> string()
	)
}

// ---
// @ Requests

fn formHeader {
	{ 'content-type': 'application/x-www-form-urlencoded' }
}

fn safeResp(r) std.default(r, {}).resp
fn volumeFormat(v) v |> string() |> str.padStart(2, '0')

// ---

fn Titler(seed, wall, ch) with http.queryEncode() {
	hex: seed
	wall: wall
	shelf: ch
}

fn reqTitler(b) with safeResp() req({
	url: endpoints.titler
	method: 'POST'
	headers: formHeader()
	body: b
})

fn handleTitler(b) reqTitler(b).body |> str.split(';')

// ---

fn Download(seed, wall, ch, vol, title) with http.queryEncode() {
	hex: seed
	wall: wall
	shelf: ch
	volume: volumeFormat(vol)
	page: ?
	title: title
}

fn reqDownload(b) with safeResp() req({
	url: endpoints.download
	method: 'POST'
	headers: formHeader()
	body: b
})

// ---

fn Bookmark(seed, wall, ch, vol, page, title) with http.queryEncode() {
	hex: seed
	wall: wall
	shelf: ch
	volume: volumeFormat(vol)
	page: page
	title: title
}

fn reqBookmark(b) with safeResp() req({
	url: endpoints.bookmark
	method: 'POST'
	headers: formHeader()
	body: b
})

fn reqHasBookmark(b) with safeResp() req({
	url: endpoints.bookmark
	method: 'GET'
	headers: formHeader()
	body: b
})

fn _redirLocation(r) r.headers.Location
fn handleBookmark(b) reqBookmark(b) |> _redirLocation()
fn handleHasBookmark(b) reqHasBookmark(b) |> _redirLocation()

// ---

fn Resource(s) with http.queryEncode() {
	extension: s
}

fn reqResource(b) with safeResp() req({
	url: endpoints.resourcelocator
	method: 'POST'
	headers: formHeader()
	body: b
})

// ---

fn Search(find, method, btnSubmit) with http.queryEncode() {
	find: find
	btnSubmit: btnSubmit |> std.default('Search')
	method: method |> std.default('x')
}

fn reqSearch(b) with safeResp() req({
	url: endpoints.search
	method: 'POST'
	headers: formHeader()
	body: b
})

// ---

TITLES_LRU_MAX := 32
TITLES_LRU := lru(TITLES_LRU_MAX)
fn getTitles(seed, wall, ch) if {
	name := query(seed, wall, ch, ?)
	val := TITLES_LRU.get(name)

	val != ? -> val
	_ -> {
		val := Titler(seed, wall, ch) |> handleTitler()
		TITLES_LRU.set(name, val)

		val
	}
}

fn getTitle(seed, wall, ch, vol) getTitles(seed, wall, ch).(vol)

fn getBook(seed, wall, ch, vol) with reqDownload() Download(
	seed
	wall
	ch
	vol
	getTitle(seed, wall, ch, vol)
)

// ---
// @@ Generations and Monte Carlo

fn powerTwo(i) 2 |> pow(i)
fn shiftLeft(value, shift) value * powerTwo(shift)
fn shiftRight(value, shift) int(value / powerTwo(shift))
fn xorOperation(input, mask, shift) input ^ ((input % mask) |> shiftLeft(shift))

fn calculateRevXorOperation(p, mask, shift) p ^ ((p % mask) |> shiftLeft(shift))
fn calculateRevRightShift(p, shift) p ^ (shiftRight(p, shift))

fn reverseXorOperation(pointer, mask, shift) {
	rev := calculateRevXorOperation(pointer, mask, shift)
	rev <- calculateRevXorOperation(rev, mask, shift)
	pointer ^ ((rev % mask) |> shiftLeft(shift))
}

fn reverseRightShift(pointer, shift) {
	rev := calculateRevRightShift(pointer, shift)
	rev <- calculateRevRightShift(rev, shift)
	pointer ^ (shiftRight(rev, shift))
}

fn RandomGenerator(seed) {
	modValue := 2 |> pow(32)
	multiplier := modValue - 1

	constant := 987654321
	previous := seed

	firstMask := '9D2C5680' |> std.fromHex()
	secondMask := 'EFC60000' |> std.fromHex()

	fn computeNext {
		pointer := (multiplier * previous + constant) % modValue

		pointer <- pointer ^ (shiftRight(pointer, 1098239))
		pointer <- xorOperation(pointer, firstMask, 698879)
		pointer <- xorOperation(pointer, secondMask, 1497599)
		pointer <- pointer ^ (shiftRight(pointer, 1797118))

		previous <- pointer
		pointer
	}

	fn reverseInt(next) {
		pointer := next

		pointer <- reverseRightShift(pointer, 1797118)

		pointer <- reverseXorOperation(pointer, secondMask, 1497599)
		pointer <- reverseXorOperation(pointer, firstMask, 698879)

		pointer <- reverseRightShift(pointer, 1098239)
		pointer <- (multiplier.inverse(pointer - constant)) % modValue
		if pointer < 0 -> pointer <- pointer + modValue
		pointer
	}

	{
		next: computeNext
		invert: reverseInt
	}
}

fn createRandomSequence(seed, count, rng) {
	if rng = ? -> rng <- RandomGenerator(seed)
	seq := []

	i := 0
	fn performAction() with seq.push() rng.next()
	fn iterate() if i < count -> {
		performAction()
		i <- i + 1
		iterate()
	}

	iterate()
	seq
}

fn reverseRandomSequence(seed, seq, rng) {
	if rng = ? -> rng <- RandomGenerator(seed)
	reversedSeq := []

	fn performReverse(value) with reversedSeq.push() rng.invert(value)
	with std.each(seq) performReverse

	reversedSeq
}